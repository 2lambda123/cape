#!/usr/bin/env python
"""
PBS `qstat` Statistics Interface
================================

:Call:

    .. code-block:: bash

        $ pqstat [OPTIONS]

:Options:
    
    -h, --help
        Display this help message and exit
        
    -u $UNAME
        Display information for *UNAME*, otherwise use the current user
        
    -q $QUEUE
        Restrict stats to a specific queue; if used without ``-u``, displays
        grand total for all users on that queue
        
:Versions:
    * 2015-07-23 ``@ddalle``: First version
    * 2017-03-02 ``@ddalle``: Added queue grand total capability
"""
# System interface modules
import os
import subprocess as sp
import cape.argread

# Primary function
def main(**kw):
    """Process and display queue statistics for a user

    :Call:
        >>> main(u=os.environ['USER'], q=None)
    :Inputs:
        *u*: {``os.environ['USER']``} | :class:`str`
            Name of user to query
        *q*: {``None``} | :class:`str`
            Specific queue; if ``None``, list all queues
    :Versions:
        * 2015-07-23 ``@ddalle``: First version
    """
    # Get user name.
    u = kw.get('u', os.environ['USER'])
    # Get queue name
    q = kw.get('q')
    # Check for "-q" with no named queue
    if q == True:
        print("WARNING: option '-q' needs a queue name; ignoring")
        q = None
    # Get the lines of qstat.
    if ("u" not in kw) and type(q).__name__.startswith("str"):
        # Get all the jobs for a queue (all users)
        try:
            # Try to run with architecture name, too
            lines = sp.check_output(
                ['qstat', '-e', q, '-W', '-o=+model']).split('\n')
        except Exception:
            try:
                lines = sp.check_output(['qstat', '-e', q]).split('\n')
            except Exception:
                lines = []
    else:
        # Get all jobs for a user (all queues)
        try:
            # Try to run with model name, too
            lines = sp.check_output(
                ['qstat', '-u', u, '-W', '-o=+model']).split('\n')
        except Exception:
            try:
                lines = sp.check_output(['qstat', '-u', u]).split('\n')
            except Exception:
                lines = []
    # Check for no jobs.
    if len(lines) < 3: return
    # Initialize stats.
    d = {}
    # Check for reasonable number of lines
    if len(lines) < 4:
        print("No jobs found.")
        return
    # Loop through lines.
    for line in lines[3:-1]:
        # Sepaparate out the properties for this script.
        vals = line.split()
        # Get the user and queue name for this job.
        qj = vals[2]
        # Model name
        try:
            nj, mj = vals[10].split(':')
        except Exception:
            mj = 'unkown'
        # Check for a requested queue.
        if (q is not None) and (qj != q[:8]): continue
        # Form a title
        tj = '%s (model=%s)' % (qj, mj)
        # Initialize the queue statistics if necessary.
        if tj not in d:
            d[tj] = {
                'R': {'jobs':0, 'nodes':0, 'cores':0, 'model':'', 'eff':0.0},
                'Q': {'jobs':0, 'nodes':0, 'cores':0, 'model':''}
            }
        # Number of nodes and cores
        nnj = int(vals[5])
        ncj = int(vals[4])
        # Add the job to the statistics.
        if vals[7] == 'R':
            # Running job.
            d[tj]['R']['jobs'] += 1
            # Current number of processed nodes and cores
            nci = d[tj]['R']['cores']
            # Current cumulative efficiency and current job efficency
            ei = d[tj]['R']['eff']
            try:
                ej = float(vals[9].rstrip('%'))
            except Exception:
                ej = 0.0
            # Nodes and cores
            d[tj]['R']['nodes'] += nnj
            d[tj]['R']['cores'] += ncj
            # Calculate efficiency
            d[tj]['R']['eff'] = (ei*nci + ej*ncj) / (nci+ncj)
            # Model name
            d[tj]['R']['model'] = mj
        elif vals[7] == 'Q':
            # Queued job.
            d[tj]['Q']['jobs'] += 1
            # Nodes and cores
            d[tj]['Q']['nodes'] += nnj
            d[tj]['Q']['cores'] += ncj
            # Model name
            d[tj]['R']['model'] = mj
    # Interpret option for showing only total
    q_total = kw.get("t", False) or kw.get("total", False)
    # Display the stats.
    show_qstats(d, q_total=q_total)

# Function to show queue statistics
def show_qstats(d, q_total=False):
    """Show queue statistics

    :Call:
        >>> show_qstats(d, q_total=False)
    :Inputs:
        *d*: :class:`dict`
            Dictionary of queue statistics
        *q_total*: ``True`` | {``False``}
            Option to only show totals
    :Versions:
        * 2015-07-23 ``@ddalle``: First version
        * 2017-06-23 ``@ddalle``: Added totals
    """
    # Initialize totals
    RT = {"jobs": 0, "nodes": 0, "cores": 0} 
    QT = {"jobs": 0, "nodes": 0, "cores": 0}
    # Loop through the queues.
    for q in d.keys():
        # Extract running qnd queued statistics
        R = d[q]['R']
        Q = d[q]['Q']
        # Add to totals
        for k in ["jobs", "nodes", "cores"]:
            RT[k] += R[k]
            QT[k] += Q[k]
        # Check for option to hide totals
        if (not q_total):
            # Display the queue name.
            print("QUEUE: %s" % q)
            # Display the running jobs statistics
            print("  R: %3i jobs, %4i nodes, %5i cores, %.1f%% efficiency"
                % (R['jobs'], R['nodes'], R['cores'], R['eff']))
            # Display the queued jobs statistics
            print("  Q: %3i jobs, %4i nodes, %5i cores"
                % (Q['jobs'], Q['nodes'], Q['cores']))
            # Totals.
            print("  T: %3i jobs" % (R['jobs']+Q['jobs']))
    # Print totals
    print("TOTALS:")
    print("  R: %3i jobs, %4i nodes, %5i cores"
        % (RT['jobs'], RT['nodes'], RT['cores']))
    # Display the queued jobs statistics
    print("  Q: %3i jobs, %4i nodes, %5i cores"
        % (QT['jobs'], QT['nodes'], QT['cores']))
    # Totals.
    print("  T: %3i jobs" % (RT['jobs']+QT['jobs']))

# Check for CLI call
if __name__ == "__main__":
    # Process inputs.
    a, kw = cape.argread.readkeys(os.sys.argv)
    # Check for help option.
    if kw.get('h') or kw.get('help'):
        print(__doc__)
        os.sys.exit()
    # Call the main function
    main(**kw)



    

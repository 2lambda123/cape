#!/usr/bin/env python
r"""
PBS `qstat` Statistics Interface
================================

:Call:

    .. code-block:: bash

        $ pqstat [OPTIONS]

:Options:
    
    -h, --help
        Display this help message and exit
        
    -u $UNAME
        Display information for *UNAME*, otherwise use the current user
        
    -q $QUEUE
        Restrict stats to a specific queue; if used without ``-u``, displays
        grand total for all users on that queue
        
:Versions:
    * 2015-07-23 ``@ddalle``: First version
    * 2017-03-02 ``@ddalle``: Added queue grand total capability
"""

# Standard library modules
import getpass
import grp
import os
import subprocess as sp

# CAPE modules
import cape.argread


# Primary function
def main(**kw):
    r"""Process and display queue statistics for a user

    :Call:
        >>> main(**k2)
    :Inputs:
        *u*, *user*: {``None``} | :class:`str`
            Name of user to query (uses ``getpass.getuser()`` if all
            three options are blank)
        *q*, *queue*: {``None``} | :class:`str`
            Specific queue; if ``None``, list all queues
        *g*, *group*: {``None``}
            Name of group to query
        *t*, *total*: ``True`` | {``False``}
            Option to only show totals
    :Versions:
        * 2015-07-23 ``@ddalle``: Version 1.0
        * 2021-09-01 ``@ddalle``: Version 1.1; add -g option
    """
    # Get user name
    u = kw.get("user", kw.get('u'))
    # Get queue name
    q = kw.get("queue", kw.get("que", kw.get('q')))
    # Get group
    g = kw.get("group", kw.get("g"))
    # Formatting options
    show_model = kw.get("show-model", kw.get("show_model", True))
    show_group = kw.get("show-group", kw.get("show_group", False))
    show_queue = kw.get("show-queue", kw.get("show_queue", True))
    # Interpret option for showing only total
    q_total = kw.get("total", kw.get("t", False))
    # Check for "-q" with no named queue
    if q is True:
        print("WARNING: option '-q' needs a queue name; ignoring")
        q = None
    if u is True:
        print("WARNING: option '-u' needs a value; using default")
        u = None
    if g is True:
        print("WARNING: option '-g' needs a value; ignoring")
        g = None
    # Default user
    if (q is None) and (u is None) and (g is None):
        # Use current user
        u = getpass.getuser()
    # Get list of users for group if needed
    if g and (u is None):
        # Get interface to group
        group = grp.getgrnam(g)
        # Convert to user
        u = ",".join(group.gr_mem)
    # Initialize command
    cmd = ["qstat", "-W", "-o=+model", "-W", "-o=+group"]
    # Check for specific queue/user
    if u:
        cmd.extend(["-u", u])
    # Check for queue option
    if q:
        cmd.extend(["-e", q])
    # Get qstat output
    try:
        lines = check_lines(cmd)
    except Exception:
        lines = []
    # Check for no jobs.
    if len(lines) < 3:
        return
    # Initialize stats.
    d = {}
    # Check for reasonable number of lines
    if len(lines) < 4:
        print("No jobs found.")
        return
    # Loop through lines.
    for line in lines[3:-1]:
        # Separate out the properties for this script
        vals = line.split()
        # Get the user and queue name for this job
        qj = vals[2]
        # Model name
        try:
            nj, mj = vals[10].split(':')
        except Exception:
            nj, mj = 0, "unknown"
        # Group name
        try:
            gj = vals[11]
        except Exception:
            gj = "unknown"
        # Check for a requested queue
        if q and (qj != q[:8]):
            continue
        if g and (gj != g):
            continue
        # Form a title
        tj = '%s (model=%s)' % (qj, mj)
        # Initialize the queue statistics if necessary.
        if tj not in d:
            d[tj] = {
                'R': {'jobs':0, 'nodes':0, 'cores':0, 'model':'', 'eff':0.0},
                'Q': {'jobs':0, 'nodes':0, 'cores':0, 'model':''}
            }
        # Number of nodes and cores
        nnj = int(vals[5])
        ncj = int(vals[4])
        # Add the job to the statistics.
        if vals[7] == 'R':
            # Running job.
            d[tj]['R']['jobs'] += 1
            # Current number of processed nodes and cores
            nci = d[tj]['R']['cores']
            # Current cumulative efficiency and current job efficency
            ei = d[tj]['R']['eff']
            try:
                ej = float(vals[9].rstrip('%'))
            except Exception:
                ej = 0.0
            # Nodes and cores
            d[tj]['R']['nodes'] += nnj
            d[tj]['R']['cores'] += ncj
            # Calculate efficiency
            d[tj]['R']['eff'] = (ei*nci + ej*ncj) / (nci+ncj)
            # Model name
            d[tj]['R']['model'] = mj
        elif vals[7] == 'Q':
            # Queued job.
            d[tj]['Q']['jobs'] += 1
            # Nodes and cores
            d[tj]['Q']['nodes'] += nnj
            d[tj]['Q']['cores'] += ncj
            # Model name
            d[tj]['R']['model'] = mj
    # Display the stats.
    show_qstats(d, q_total=q_total)

# Function to show queue statistics
def show_qstats(d, q_total=False):
    """Show queue statistics

    :Call:
        >>> show_qstats(d, q_total=False)
    :Inputs:
        *d*: :class:`dict`
            Dictionary of queue statistics
        *q_total*: ``True`` | {``False``}
            Option to only show totals
    :Versions:
        * 2015-07-23 ``@ddalle``: First version
        * 2017-06-23 ``@ddalle``: Added totals
    """
    # Initialize totals
    RT = {"jobs": 0, "nodes": 0, "cores": 0} 
    QT = {"jobs": 0, "nodes": 0, "cores": 0}
    # Loop through the queues.
    for q in d.keys():
        # Extract running qnd queued statistics
        R = d[q]['R']
        Q = d[q]['Q']
        # Add to totals
        for k in ["jobs", "nodes", "cores"]:
            RT[k] += R[k]
            QT[k] += Q[k]
        # Check for option to hide totals
        if (not q_total):
            # Display the queue name.
            print("QUEUE: %s" % q)
            # Display the running jobs statistics
            print("  R: %3i jobs, %4i nodes, %5i cores, %.1f%% efficiency"
                % (R['jobs'], R['nodes'], R['cores'], R['eff']))
            # Display the queued jobs statistics
            print("  Q: %3i jobs, %4i nodes, %5i cores"
                % (Q['jobs'], Q['nodes'], Q['cores']))
            # Totals.
            print("  T: %3i jobs" % (R['jobs']+Q['jobs']))
    # Print totals
    print("TOTALS:")
    print("  R: %3i jobs, %4i nodes, %5i cores"
        % (RT['jobs'], RT['nodes'], RT['cores']))
    # Display the queued jobs statistics
    print("  Q: %3i jobs, %4i nodes, %5i cores"
        % (QT['jobs'], QT['nodes'], QT['cores']))
    # Totals.
    print("  T: %3i jobs" % (RT['jobs']+QT['jobs']))


# Get lines from system call
def check_lines(cmd):
    r"""Capture STDOUT and split into list of lines

    :Call:
        >>> lines = check_lines(cmd)
    :Inputs:
        *cmd*: :class:`list`\ [:class:`str`]
            List of words of system command
    :Outputs:
        *lines*: :class:`list`\ [:class:`str`]
            List of lines in STDOUT (with \n stripped)
    :Versions:
        * 2021-09-01 ``@ddalle``: Version 1.0
    """
    # Call check_output()
    txt = sp.check_output(cmd)
    # Decode and split
    return txt.decode("utf-8").split("\n")


# Check for CLI call
if __name__ == "__main__":
    # Process inputs.
    a, kw = cape.argread.readkeys(os.sys.argv)
    # Check for help option.
    if kw.get('h') or kw.get('help'):
        print(__doc__)
        os.sys.exit()
    # Call the main function
    main(**kw)



    
